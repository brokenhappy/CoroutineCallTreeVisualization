FILE: deepNesting.kt
    public final class TestTracker : R|com/woutwerkman/calltreevisualizer/StackTrackingContext| {
        public constructor(): R|TestTracker| {
            super<R|kotlin/Any|>()
        }

        public final val calls: R|kotlin/collections/MutableList<kotlin/String>| = R|kotlin/collections/mutableListOf|<R|kotlin/String|>()
            public get(): R|kotlin/collections/MutableList<kotlin/String>|

        @R|com/woutwerkman/calltreevisualizer/NonTracked|() public open override suspend fun <T> track(functionFqn: R|kotlin/String|, child: R|suspend () -> T|): R|T| {
            this@R|/TestTracker|.R|/TestTracker.calls|.R|SubstitutionOverride<kotlin/collections/MutableList.add: R|kotlin/Boolean|>|(<strcat>(String(enter:), R|<local>/functionFqn|))
            ^track try {
                R|<local>/child|.R|SubstitutionOverride<kotlin/coroutines/SuspendFunction0.invoke: R|T|>|()
            }
            finally {
                this@R|/TestTracker|.R|/TestTracker.calls|.R|SubstitutionOverride<kotlin/collections/MutableList.add: R|kotlin/Boolean|>|(<strcat>(String(exit:), R|<local>/functionFqn|))
            }

        }

        public open override val key: R|kotlin/coroutines/CoroutineContext.Key<*>|
            public get(): R|kotlin/coroutines/CoroutineContext.Key<*>| {
                ^ Q|com/woutwerkman/calltreevisualizer/StackTrackingContext|
            }

    }
    public final suspend fun level1(): R|kotlin/String| {
        ^level1 R|/level2|()
    }
    public final suspend fun level2(): R|kotlin/String| {
        ^level2 R|/level3|()
    }
    public final suspend fun level3(): R|kotlin/String| {
        ^level3 String(deep)
    }
    public final fun box(): R|kotlin/String| {
        lval tracker: R|TestTracker| = R|/TestTracker.TestTracker|()
        lvar result: R|kotlin/Result<kotlin/String>?| = Null(null)
        lval coro: R|suspend () -> kotlin/String| = fun <anonymous>(): R|kotlin/String| <inline=Unknown>  {
            ^ R|/level1|()
        }

        R|<local>/coro|.R|kotlin/coroutines/startCoroutine|<R|kotlin/String|>(object : R|kotlin/coroutines/Continuation<kotlin/String>| {
            private constructor(): R|<anonymous>| {
                super<R|kotlin/Any|>()
            }

            public open override val context: R|kotlin/coroutines/CoroutineContext| = R|<local>/tracker|
                public get(): R|kotlin/coroutines/CoroutineContext|

            public open override fun resumeWith(res: R|kotlin/Result<kotlin/String>|): R|kotlin/Unit| {
                R|<local>/result| = R|<local>/res|
            }

        }
        )
        lval value: R|kotlin/String| = R|<local>/result|!!.R|kotlin/getOrThrow|<R|kotlin/String|>()
        lval expected: R|kotlin/collections/List<kotlin/String>| = R|kotlin/collections/listOf|<R|kotlin/String|>(vararg(String(enter:level1), String(enter:level2), String(enter:level3), String(exit:level3), String(exit:level2), String(exit:level1)))
        ^box when () {
            ==(R|<local>/tracker|.R|/TestTracker.calls|, R|<local>/expected|) && ==(R|<local>/value|, String(deep)) ->  {
                String(OK)
            }
            else ->  {
                <strcat>(String(FAIL: calls=), R|<local>/tracker|.R|/TestTracker.calls|, String(, value=), R|<local>/value|)
            }
        }

    }
